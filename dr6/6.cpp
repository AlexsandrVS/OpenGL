#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <climits>

using namespace std;

#define V 7 // Количество вершин в графе

// Функция для нахождения минимума из двух значений
int min(int a, int b) {
    return (a < b) ? a : b;
}

    // DFS (Depth-First Search) - это алгоритм обхода графа, 
    // который исследует как можно глубже в каждую ветвь перед тем, 
    // как возвращаться к исходной ветви и исследовать следующую. Вот как это работает:
    // Выбор начальной вершины: Начиная с выбранной начальной вершины, алгоритм помечает её как посещённую и 
    // добавляет её в стек (или рекурсивно вызывает себя для поиска из этой вершины).
    // Поиск в глубину: Для текущей вершины алгоритм ищет непосещённую смежную вершину. 
    // Если такая вершина найдена, она помечается как посещённая и добавляется в стек (или рекурсивно вызывается для неё). Если нет непосещённой смежной вершины, текущая вершина извлекается из стека (или возвращается из рекурсивного вызова), и поиск продолжается из предыдущей вершины.
    // Повторение шага 2: Этот процесс повторяется, пока стек не опустеет или не будет пройдено все рёбра графа.
    // Пока существует путь от истока к стоку в остаточной сети

// Поиск увеличивающего пути с использованием обхода в глубину
bool dfs(vector<vector<int>>& residualGraph, int s, int t, int parent[]) {

    bool visited[V];                     // Массив для отслеживания посещенных вершин
    memset(visited, 0, sizeof(visited)); // Инициализация всех вершин как непосещенных

    queue<int> q; // Очередь для обхода в глубину
    q.push(s); // Добавление источника в очередь
    visited[s] = true; // Помечаем источник как посещенный
    parent[s] = -1; // Источник не имеет родителя

    while (!q.empty()) { // Пока очередь не пуста
        int u = q.front(); // Получаем вершину из очереди
        q.pop(); // Удаляем вершину из очереди

        for (int v = 0; v < V; v++) { // Перебираем все вершины
            if (!visited[v] && residualGraph[u][v] > 0) { // Если вершина не посещена и есть ребро (u, v) с ненулевой пропускной способностью
                q.push(v); // Добавляем вершину в очередь
                parent[v] = u; // Запоминаем вершину-родителя для вершины v
                visited[v] = true; // Помечаем вершину как посещенную
            }
        }
    }

    return visited[t]; // Возвращаем true, если сток t был достигнут при обходе
}

// Функция для нахождения максимального потока методом Форда-Фалкерсона
int fordFulkerson(vector<vector<int>>& graph, int source, int sink) {

    vector<vector<int>> residualGraph = graph; //буфер или остаточная сеть

    // 1. Обнуляем все потоки. Остаточная сеть изначально совпадает с исходной
    // сетью.

    int parent[V];   // Для хранения пути, найденного во время алгоритма обхода графа
    int maxFlow = 0; // Изначально поток равен нулю

    // 2. В остаточной сети находим любой путь из источника в сток. Если такого
    // пути нет, останавливаемся.

    // 3. Пускаем через найденный путь максимально возможный поток:
        // 1. На найденном пути в остаточной сети ищем ребро с минимальной
        // Сmin пропускной способностью.
        // 2. Для каждого ребра на найденном пути увеличиваем поток на Сmin, а
        // в противоположном ему — уменьшаем на Сmin.
        // 3. Модифицируем остаточную сеть. Для всех рёбер на найденном
        // пути, а также для противоположных (антипараллельных) им рёбер,
        // вычисляем новую пропускную способность f.

    // 4. Возвращаемся на шаг 2.

    // Пока существует путь в остаточной сети
    while (dfs(residualGraph, source, sink, parent)) {
        int pathFlow = INT_MAX;

        // 1. На найденном пути в остаточной сети ищем ребро с минимальной
        // Сmin пропускной способностью.

        // Находим минимальную пропускную способность ребер на пути
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            pathFlow = min(pathFlow, residualGraph[u][v]);
        }

        // Обновляем остаточную сеть
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];

            // 2. Для каждого ребра на найденном пути увеличиваем поток на Сmin, а
            // в противоположном ему — уменьшаем на Сmin.

            residualGraph[u][v] -= pathFlow;
            residualGraph[v][u] += pathFlow;
        }

        // Прибавляем поток текущего пути к общему потоку
        maxFlow += pathFlow;
    }

    return maxFlow;
}

void printMaxFlowPath(vector<vector<int>>& graph, int source, int sink) {
    vector<vector<int>> residualGraph = graph; // Создаем копию графа для работы с остаточной сетью
    int parent[V]; // Массив для хранения пути
    int maxFlow = fordFulkerson(graph, source, sink); // Находим максимальный поток методом Форда-Фалкерсона


    // Если максимальный поток равен 0, то нет пути от истока к стоку
    if (maxFlow == 0) {
        cout << "There is no path from source to sink." << endl;
     
        return; // завершаем алгоритм
    }

    cout << "Maximum Flow in the network: " << maxFlow << endl;
    cout << "Path of the maximum flow: \n";

    // Пока существует путь от истока к стоку в остаточной сети
    while (dfs(residualGraph, source, sink, parent)) {
        int pathFlow = INT_MAX;

        // Находим минимальную пропускную способность ребер на пути
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            pathFlow = min(pathFlow, residualGraph[u][v]);
        }

        // Выводим вершины пути и их поток
        cout << "Path: ";
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            cout << u << " -> ";
        }
        cout << sink << " (Flow: " << pathFlow << ")" << endl;

        // Обновляем остаточную сеть
        for (int v = sink; v != source; v = parent[v]) {
            int u = parent[v];
            residualGraph[u][v] -= pathFlow;
            residualGraph[v][u] += pathFlow;
        }
    }
}


int main() {
    vector<vector<int>> graph = {
        {0, 6, 12, 3, 11, 18, 13},
        {0, 0, 0, 0, 5, 12, 13},
        {0, 0, 0, 4, 0, 8, 14},
        {0, 0, 0, 0, 0, 0, 10},
        {0, 0, 0, 0, 0, 7, 8},
        {0, 0, 0, 0, 0, 0, 7},
        {0, 0, 0, 0, 0, 0, 0}
    };

    int source = 0; // Исток
    std::cout << "Input sourse:\t";
    std::cin >> source;

    int sink = 0;   // Сток
    std::cout << "Input sink: \t";
    std::cin >> sink;

    // 1. Обнуляем все потоки. Остаточная сеть изначально совпадает с исходной
    // сетью.

    // 2. В остаточной сети находим любой путь из источника в сток. Если такого
    // пути нет, останавливаемся.

    // 3. Пускаем через найденный путь максимально возможный поток:
        // 1. На найденном пути в остаточной сети ищем ребро с минимальной
        // Сmin пропускной способностью.
        // 2. Для каждого ребра на найденном пути увеличиваем поток на Сmin, а
        // в противоположном ему — уменьшаем на Сmin.
        // 3. Модифицируем остаточную сеть. Для всех рёбер на найденном
        // пути, а также для противоположных (антипараллельных) им рёбер,
        // вычисляем новую пропускную способность f.
    // 4. Возвращаемся на шаг 2.

    printMaxFlowPath(graph, source, sink);

    return 0;
}
